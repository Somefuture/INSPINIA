---
title: 从浏览器地址栏输入url开始
---
目录：
[[toc]]

<!-- markdownlint-disable MD033 -->

### 要点总结

1. DNS解析：将域名解析成IP地址
2. 建立TCP连接：TCP三次握手
3. TLS协商（仅HTTPS请求）
4. 发送HTTP请求
5. 服务器处理请求并返回HTTP报文
6. 浏览器解析渲染页面
7. 断开连接：TCP四次挥手

### 详细解析

1. url的定义（Uniform Resource Locator 统一资源定位符），用于定位互联网上的资源，以下面这个为例：

    ```s
      HTTP://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
    ```

    * `HTTP`是协议。它表明了浏览器必须使用哪一种协议，通常为HTTP协议和HTTPS协议。[HTTP和HTTPS的区别](#HTTP和HTTPS的区别)
    web浏览器中常见的是这种，浏览器也知道如何处理其他协议，比如：`mailto:(打开邮件客户端)`或者`ftp:(处理文件传输)`

    * `www.example.com`是域名。它表明正在请求哪个web服务器。或者可以直接使用IP address。DNS（DomainName System 域名系统）的作用就是将域名映射到服务对应的ip地址。

    * `80`是端口。它表示用于访问web服务器伤的资源的技术“门”。如果web服务没有特别指出端口，则使用HTTP协议的默认端口（HTTP：80，HTTPS：443）。

    * `/path/to/myfile.html`是网络服务器上资源的路径。在web的早期阶段，这种路径表示web服务器上物理文件的位置。但是如今，它主要是由没有任何物理实现的web服务器处理的抽象。例如单页面应用的路径并不能表示物理位置，而是运行js代码加载的相对应的资源。

    * `?key1=value1&key2=value2`是提供给网络服务器的额外参数。在返回资源之前，web服务器可以使用这些参数来执行额外的操作。

    * `#SomewhereInTheDocument`是资源身的另一部分的锚点，表示资源中的一种“书签“。比如：在html文档上，浏览器将滚动到定义锚点的位置；在视屏音频文档上，浏览器将尝试转到锚点所代表的时间。且：#后面的内容（片段标志符）不会被发送到请求的服务器,以下图为例，刷新该地址，HTTP请求中并不会将锚点后的内容向服务器进行请求。

    ![url](/images/url.png)
    ![HTTP请求](/images/HTTP.png)

2. 域名与DNS(DomianName System)

    * 域名为互联网可用的网页服务器提供了方便人类理解的地址。当你在注册商那注册了一个域名，几个小时内，所有的DNS服务器都会收到你的DNS信息。我们在访问一个域名的时候，通常会向网络服务商的最底层的DNS服务器查询域名，如果没有查询到，就会去上一级的服务器查询，一直到从顶级服务器中查询到你的域名为止。并且这个结果，会缓存在底层的DNS服务器里。

    * DNS请求的工作流程：

        ```s
        1. 在你的浏览器地址栏输入baidu.com
        2. 浏览器询问计算机是否已经已经识别此域名所确定的IP地址（使用本地DNS缓存）。
           如果是的话，这个域名就会被转换为IP地址，然后浏览器与网络服务器交换内容，结束域名解析流程。
        3. 如果你的计算机不知道baidu.com域名背后的IP,它会询问一个DNS服务器，这个服务器的功能就是告诉你的计算机已经注册的域名所匹配的IP.
        4. 然后计算机就知道了要请求的IP地址，你的浏览器能够与网络服务器建立连接
        ```

3. TCP握手

    握手过程：

    ```s
    1. 客户端发送一个带SYN=1，Seq=X的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
    2. 服务器收到这个数据包之后，发回一个带SYN=1,ACK=X+1,Seq=Y的响应包，传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受请求了，你可以发送了）
    3. 客户端再回传一个带ACK=Y+1,Seq=Z的数据包，代表“握手结束”，连接建立成功，开始数据传输（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）
    ```

    三次握手的原因：

    ```s
    为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
    ```

4. TLS协商。为了在HTTPS上建立安全连接，我们需要进行TLS协商。它会决定服务端和客户端进行通信加密使用的秘钥，传播公钥时使用的是非对称加密，然后传输数据时，使用对称加密。

5. 在浏览器和服务器之间，有许多的计算机和其它设备转发了HTTP消息，比如你的路由器、网线。这些主要出现在传输层、网络层和物理层上，所以你的宽带网速，也很大程度上的影响了你网页的加载速度。但是在这中间，我们可能会通过代理，去向服务器请求我们需要的资源。目前适用范围最广的代理是：nginx。

    nginx代理服务器的主要作用：

    * 缓存，但是当cache control: privite时，不允许代理服务器进行缓存
    * 过滤（像反病毒扫描，家长控制）
    * 负载均衡（让多个服务器服务不同的请求）
    * 认证（对不同资源进行权限管理）
    * 日志记录（允许存储历史信息）

6. HTTP请求

    一旦我们建立了到web服务器的连接，浏览器就代表用户发送了一个初始的HTTP GET请求，对于网站来说，这个请求通常是一个HTML文件。一旦服务器收到请求，它将使用相应的响应头和html的内容进行回复。

7. TCP慢开始/14kb规则。 第一个响应包的大小是14kb。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法，慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。在收到初始包之后，服务器会将下一个包的大小加倍到28kb，然后后续包依次是前一个包大小的2倍，直到到达预定的阈值或者遇到堵塞。

8. 一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。这就是为什么在前14kb中包含浏览器开始渲染页面所需的所有内容，至少包含页面模板（第一次渲染所需的css和html）对于web性能优化来说至关重要。

9. 浏览器解析过程：

    * 处理HTML标签并构造DOM树。良好的文档格式，有利于加快dom树的解析速度。dom节点的数量越多，构建dom树需要的时间就越长。DOM树解析的过程是一个深度优先遍历，会先构建初当前节点的所有字节点，再构建下一个兄弟节点。

    * 当解析器发现非阻塞资源例如图片或者css文件时，解析也可以继续进行。但是对于`<script>`标签(特别说没有async或者defer属性的script标签),会阻塞渲染并停止HTML的解析。可以使用`<link rel="preload" href="main.js" as="script">` link的rel属性配置预加载，这样在随后的页面渲染中，一旦需要使用到它们，它们就立刻可用，不需要停止html解析

    * 接下来是处理css并构建CSSOM树。（尽量避免使用后代选择器，因为css树计算时，先匹配后代，再对父元素进行匹配，相对于具名类选择器来说，性能非常的差）

    * 当css被解析并创建COSSOM时，js文件被解释、编译和执行。脚本被解析为抽象语法树（Abstract Syntax Tree）.一些浏览器引擎使用AST并将其传递到解释器中，输出在主线程执行的字节码。这就是js编译的过程。

    * 浏览器还会构建辅助设备用户分析和解释内容的辅助功能树-可访问性对象模型（AOM）类似DOM的语义版本，这也是为什么我们在开发网页的时候，推荐使用语义化的标签，更加有利于构建清晰的可访问对象。在构建AOM之前，屏幕阅读器无法访问内容

    * dom树和cssom树构造完毕以后，浏览器会将DOM树和cssom树组合成一个Render树，计算render树从dom树的根开始构建，遍历每个可见节点。（display:none的节点不会出现在render树上，visibility:hidden的节点会出现在render树上,且会占用空间）。render树会将所有相关样式匹配到dom树中的每个可见节点，并根据css的层级确定每个节点的样式。

    * 接下来是在渲染树上运行布局以计算每个节点的几何体。第一次确定节点的大小和位置称为布局。随后对节点的大小和位置的重新计算称为回流。为了确定每个DOM节点的确切大小和位置。浏览器会从渲染树的根开始遍历，因此布局和回流是十分耗费性能的。

    * 最后一步是将各个节点绘制到屏幕上。在绘制阶段，浏览器将把元素的每个可视化部分绘制到屏幕上。绘制可以将布局树中的元素分解为多个层，将内容提升到GPU上的层，可以提高绘制和重绘的性能。层的确可以提高性能，但是它以内存管理为代价。所以不应该过度使用。

    * 当文档的各个部分以不同的层绘制，互相重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上。

    * 一旦主线绘制页面完成，如果主线程正在解析、编译和执行js，则此时页面还是无法及时响应用户交互，当相关js执行完毕，页面进入可交互状态。

    * 到此，一个完整的页面加载完毕。为了不需要每请求一个HTTP就要建立一个tcp连接，HTTP1.1提出了HTTP keep-alive，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

    * 当请求头中出现：Conection:close时，tcp连接会关闭。关闭TCP连接的四次挥手：

        * 第一次挥手，由浏览器发起，告诉服务器：我请求报文发送完了，你准备关闭吧
        * 第二次挥手，由服务器发起，告诉浏览器：我请求报文接收完了，我准备关闭了，你也准备吧
        * 第三次挥手，由服务器发起，告诉浏览器：我响应报文发送完了，你准备关闭吧
        * 第四次挥手，由浏览器发起，告诉服务器：我响应报文接收完了，我准备关闭了，你也准备吧。然后服务器收到挥手后，关闭连接。然后浏览器还等待一定时间未收到回复，则正常关闭。

### HTTP状态码

|状态码|分类|描述
|:-----:|:----------|:-------------------|
| 100 Continue |信息响应|客户端应继续其请求, 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分|
|101 Switching Protocols| 信息响应 | 切换协议。表示服务器回应客户端升级协议的请求（Upgrade请求头），正在切换协议。且会发送一个Upgrade响应头来表明正在切换过去的协议。在使用WebSokects时会用到协议切换。
|103 Early Hints| 信息响应| 一般和Link header 一起使用，用来允许用户在服务器还在准备响应数据的时候，预加载一些资源|
|200 OK|成功响应| 成功的含义取决于HTTP Methods:<br>`GET: 资源已被提取并正在消息正文中传输`<br>`HEAD:实体标题头位于消息正文中`<br>`POST:描述动作结果的资源在消息体中传输`<br>`TRACE:消息正文包含服务器收到的请求消息`|
|201 created|成功响应|请求已成功，并因此创建了一个新的资源。通常作用于POST请求或者某些PUT请求之后返回的响应|
|202 Accepted|成功响应|表示该请求已经被接收但尚未起作用。202状态码适合异步任务或者处理时间比较长的请求，避免HTTP连接一直占用、超时。（MQ异步处理披任务，客户端定时轮训结果）|
|203 Non-Authoritative Infomation|成功响应| 非权威内容，服务器成功处理了这个请求，但是代理服务器对内容做出了一些改动。代理服务器通过这个状态码告诉用户，成功获取内容，但是这部份内容和原始服务器返回的内容可能不完全一致|
|204 No Content|成功响应|服务器成功处理了请求，但不需要返回任何实体内容。如果客户端是浏览器的话，那么浏览器应保留了发送该请求的页面，而不产生任何文档视图上的变化。|
|205 Reset Content|成功响应|服务器成功处理了请求,且没有返回任何内容。该请求要求请求者重置文档视图。该响应主要是被用于接收用户输入后，立即重置表单|
|206 Partial Content|成功响应|部分请求成功|
|300 Multiple Choice|重定向响应|多项选择，客户端请求了实际上指向多个资源的url，这个状态码是和一个选项列表一起返回的，用户可以选择想要的选项|
|301 Moved Permanently|重定向响应|被请求的资源已永久移动到新位置，除非额外指定，否则响应可缓存|
|302 Found|重定向响应|请求的资源现在临时从不同的url响应请求。指定Cache-Control或Expires后，才可缓存|
|303 See Other|重定向响应|对应当前请求的响应可以在另一个URL上被找到，且客户端应采用Get方法去访问该资源|
|304 Not Modified|重定向响应|服务器验证该请求请求的内容本地的缓存是有效的，就会返回此状态码，让客户端使用缓存的内容|
|305 Use Proxy|重定向响应|使用代理。所请求的资源必须通过代理访问，代理的地址会出现在Location里。只有原始服务器才能建立305响应|
|307 Temporary Redirect|重定向响应|临时重定向响应，指定Cache-Control或Expires后，才可缓存|
|308 Permanent Redirect|重定向响应|这意味着资源永久位于由Location:HTTP Response 指定的另一个URL。类似301.但是用户代理不能更改所使用的HTTP Methods|
|400 Bad Request|客户端响应|1.语义有误，当前请求无法被服务器理解 2. 请求参数有误|
|401 Unauthorized|客户端响应|当前请求需要用户的身份认证。该响应必须包含一个适用于被请求资源的WWW-Authorization 请求头用以询问用户信息|
|403 Forbidden|客户端响应|服务器已经理解请求，但是拒绝执行它。有时通过nginx代理的域名访问时，浏览器会返回403页面，是因为autoindex为off，不会自动创建索引|
|404 Not Found|客户端响应|请求失败，服务器上没有找到该请求需要的资源。|
|405 Method Not Allowed|客户端响应|请求中指定的请求方法不能被用户请求响应的资源，因为PUT、DELETE方法会对服务器上的资源进行写操作，因此大部分的网页服务器都不支持或者默认配置下不允许上述请求方法，均会返回405错误|
|406 Not Acceptable|客户端响应|请求的资源的内容特性无法满足请求头中的条件，因为无法生成响应实体|
|408 Request Timeout|客户端响应|客户端请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送|
|429 Too Many Requests|客户端响应|用户在给定的时间内发送了太多请求。（用于限制请求速率）|
|500 Internal Server Error|服务端响应|服务器遇到了不知道如何处理的情况|
|501 Not Implemented|服务端响应|服务器不支持客户端发送的HTTP Method，比如CONNECT方法，只在HTTP1.1中被定义，但是你的web服务器版本比较旧则会触发501错误|
|502 Bad Gateway|服务端响应|错误的网关，作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|
|503 Service Unavailable| 服务端响应|服务器没有准备好处理请求。常见原因时服务器因维护或者重载而停机|
|504 Gateway Timeout|服务端响应|当服务器作为网关，不能及时得到响应时返回此错误代码|
|505 HTTP Version Not Support|服务端响应|服务器不支持请求中所使用的HTTP协议版本|

### http状态码301和302的区别

1. 定义不同。301表示被请求的资源已永久移动到新位置，并且将来对此资源的引用都应该使用这个响应返回的URL，客户端后续访问，会自动将地址改为新的URL。302表示请求的资源现在临时从不同的URL响应请求,后续再次访问时，依旧访问原来的地址。
2. 缓存策略不同。301浏览器默认缓存，302浏览器默认不缓存。
3. 搜索引擎对其的处理不同。301旧地址A的资源永久移除，重定向到网址B，搜索引擎会抓取网址B的内容，同时将网址保存为B网址。302旧地址A的资源仍然可以访问，这个重定向只是临时从旧地址A跳转到B地址，这时搜索引擎会抓取网址B的内容，但是网址依旧保存为A的。
4. 安全。302重定向容易造成网址劫持现象。

### HTTP Methods

1. GET

    * 从指定的资源请求数据，查询字符串是在GET请求的url中发送的。
    * 请求可被缓存。
    * 请求保存在浏览器历史记录中，可被收藏为书签
    * 不应该在处理敏感数据时使用，防止sql注入，不应该直接使用get请求的参数进行sql拼接
    * 请求有长度限制，浏览器对url长度有2kb到8kb的长度限制。如果超出web服务器的限制，会返回`414 Request-URI Too Long`
    * 请求只应当用于取回数据

2. HEAD

    * 请求一个与Get请求的响应相同的响应，但是没有响应体
    * 使用场景：在下载一个大文件前先获取其大小再决定是否下载，以此节约带宽资源

3. POST

    * 向指定的资源提交要被处理的数据，提交的信息是在http请求体（Request Body）中发送的
    * 不会被缓存
    * 请求不会保留在浏览器历史记录中，不能被收藏为书签
    * 对数据长度没有要求,数据不会显示在url中

4. PUT

    * 使用请求中的参数创建或者替换目标资源。
    * put和post不同的是，put调用一次与连续调用多次是等价的，不存在副作用。连续调用多次post方法，可能会产生重复提交。
    * 如果目标资源不存在，并且put方法创建成功，那么源服务必须返回201 created来通知客户端资源已创建。如果目标资源已存在，且按照请求更新成功，源头服务器必须返回200 OK或者204 no content。

5. DELETE

    * 用于删除指定的资源
    * delete方法成功执行，可能会有以下几种状态码：
        202（Accepted）表示请求的操作可能会成功执行，但是还没开始执行
        204（No Content）表示操作已执行，但是无进一步的相关信息
        200（OK）表示操作已执行，并且响应中提供了相关状态的描述信息

6. CONNECT

    * CONNECT方法可以开启一个客户端与所请求资源之间的双向沟通通道。
    * 只有当浏览器配置为使用代理服务器时才会用到CONNECT方法。

7. OPTIONS

    * 用于检测服务器所支持的HTTP方法
    * 在CORS中，可以使用OPTIONS方法发起一个预检请求，以检测实际请求是否可以被服务器所接收

8. TRACE 沿着目标资源的路径执行一个消息环回测试

9. PATCH 用于对资源进行部分修改

### HTTP和HTTPS的区别

https默认工作在TCP协议443端口，它的工作流程：

* TCP三次握手
* 客户端验证服务器数字证书
* DH算法协商堆成加密算法的密钥、hash算法的密钥
* SSL/TLS安全加密隧道协商完成
* 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

http与https的区别：

* http明文传输，数据都是未加密的，安全性较差，HTTPS数据传输过程是加密的，安全性更好；
* 使用HTTPS协议需要到数字证书认证机构申请证书
* HTTP页面响应速度比HTTPS快，主要是因为http使用TCP三次握手连接，客户端和服务器需要交换三个包，而HTTPS除了tcp的三个包，还要加上ssl握手的九个包，一共就是12个包。
* 默认端口号不同，HTTP:80, HTTPS:443
* HTTPS其实就是构建在SSL/TLS上的HTTP协议，所以更加耗费性能

### HTTP缓存

存储策略发生在收到请求响应后，用于决定是否缓存响应资源；

过期策略发生在请求前，用于判断缓存是否过期;

协商策略发生在请求中，用于判断缓存资源是否更新.

> 缓存又分为强缓存和弱缓存（又称为协商缓存）。其中强缓存包括Expires和Cache-Control，主要是在过期策略生效时应用的缓存。
> 弱缓存包括Last-Modified和ETag, 是在协商策略后应用的缓存。强弱缓存之前主要的区别在于：获取资源时是否会发送请求。

![cache-control可选值](/images/cache.jpeg)

1. Expires 指定缓存的过期时间，为某一时刻的时间，参考本地时间进行对比，在指定时刻后过期。因为客户端的本地时间是不可控且不可改的，所以这种缓存方式会产生很大的弊端。

2. Cache-Control 用于指定资源的缓存机制，可以同时在请求头和响应头中设定，涉及缓存策略和过期策略。缓存指定如下：

    ![cache-control可选值](/images/cache-control.jpeg)

3. max-age=0主要应用于请求头中，表示不使用强缓存，但允许协商缓存。chrome和firefox浏览器的刷新操作，都是在请求头上加了max-age=0指令

4. max-age 用于响应头的时候，主要是指定缓存过期的相对时间。资源到达指定时间后过期。功能类似Espires，但优先级更高。

5. no-cache 表示跳过强缓存，强制进去协商缓存策略；no-store指不缓存文件。

6. 强制刷新浏览器的时候，会自动带上Pragma: no-cache 和Cache-Control: no-cache,并且不会带上协商策略中所涉及的信息。（也就是不会使用任何缓存，重新获取资源）

7. Last-Modified 用于标记请求的资源的最后一次修改时间，格式为GMT时间，但是Last-Modified 只能精确到秒，因此不适合在一秒内多次改变的资源。请求返回的资源带有Last-Modified标识时，再次请求该资源，浏览器会自动带上If-Modified—Since，值为返回的Last-Modified 值。请求到达服务器后，服务器进行判断，如果从上次更新后没有再更新，则返回304，告诉浏览器使用缓存的资源。如果更新过了，那么就返回新的资源，并且带上新的last-modified值。

8. ETag是请求资源在服务器的唯一标识，浏览器可以根据ETag值缓存数据。在再次请求时通过If-None-Match携带上次的ETag值,如果值不变，则返回304，如果改变则返回新的内容。

9. ETag优先级高于Last-Modified。

缓存优缺点：

|缓存头部|优点|缺点|
|--------------|:---|:-----|
|Expires|1.HTTP1.0产物，可以在HTTP1.0和1.1中使用<br>2.简单易用，通过绝对时间标识失效时间|1. 时间为服务器返回的时间，如果本地时间与服务器时间不一致，可能会出现问题<br>2.存在版本问题，在资源过期之前如果对资源进行修改，客户端无法获知。|
|Cache-Control|1.HTTP1.1产物，以相对时间标识失效时间，解决了Expires服务器和客户端相对时间的问题。<br>2. 支持的指令很多，可以依据需求进行响应的配置|1. 不适用于HTTP1.0<br>2. 与Expires类似，存在版本问题。在资源过期之前对资源进行修改，客户端都是无法感知的|
|Last-Modified|1.不存在版本问题，每次都会跟服务器进行校验，符合则304不返回资源，不符合则返回资源|1.以时刻作为标识，精确到秒，无法识别一秒内进行多次修改的情况|
|ETag|1. 不存在版本问题，每次都会跟服务器进行校验，符合则304不反悔资源，不符合则重新返回资源<br>2. 可以更加精确的判断资源是否被修改<br>3.可以识别一秒内多次修改的情况|1.计算ETag值会对性能造成一定消耗<br>2.分布式服务器存储的情况下，需要保证计算ETag的算法一致，如果不一致，则会导致资源在不同服务器上验证不通过|

### HTTP1.0 到 HTTP1.1 到HTTP2.0

* HTTP/0.9 单行协议 以唯一可用方法GET开头，其后跟目标资源路径。响应也只包含响应文档本身。只能传送HTML文件，没有状态码和错误代码。

```s
    GET /mypage.html
```

* HTTP/1.0 构建可拓展性

```s
1. 引入了HTTP头的概念，无论是对于请求还是响应，允许传输元数据，使协议变得非常灵活
2. 具备装束纯文本HTML文件以外其它文档的能力（Content-Type）
3. 增加了状态码，使浏览器可以了解请求执行成功或失败
4. 一个HTTP请求就需要建立一个TCP连接
```

* HTTP/1.1 标准化协议

```s
1. 连接可以复用，节省了多次打开TCP连接加载网页资源的时间
2. 增加管线化技术，允许在第一个响应被完全发送之前就发送第二个请求，以降低通信延迟
3. 支持响应分块，利用这一机制，可以实现长链接
4. 引入额外的缓存控制机制
5. 引入内容协商机制，包括语言、编码、类型等，并允许客户端和服务器之间约定以最合适的内容进行交换
6. 引入了Host头，能够设置域名+端口，能够使不同的域名配置在同一个IP地址的服务器上

WebSocket 通过升级现有HTTP协议建立双向socket连接

X-Frame-Options 响应头，指示页面是否可以在iframe中嵌套

```

* HTTP/2.0

全双工通信：浏览器针对同一个域名的资源，只建立一个TCP连接通道，所有针对这个域名的请求全部在这个通道中完成，并且引入了流的机制，这条通道可以同时处理多个request。且request的响应不会因为上一个request的响应未处理完成而阻塞，彻底解决了http层面的队头阻塞。

http2将每一个request切割为更小的帧，有header帧和body帧，并且给同一个request帧分配相同的streamId，模拟实现了流的传输。

```s
与http/1.0 不同之处：
1. 新的二进制格式进行传输，解析速度更快
2. 多路复用，所有相同域名的请求，都通过同一个TCP连接并发完成，可以避免队头阻塞问题，极大的提高了传输性能。http1.1针对同一个域名的最大TCP连接数是6
3. 头部压缩，移除了传输重复数据的成本
4. 服务端推送：还没收到浏览器请求，服务器就把各种资源推送给浏览器（可以通过nginx http2_push 命令实现；可以通过Link preload 实现）
```

### link preload 的好处

* 更加精确的优化资源加载优先级
* 匹配未来的加载需求，在适当的情况下，重复利用同一资源
* 为资源应用正确的内容安全策略
* 为资源设置正确的Accept请求头

### GPU&web性能优化

* 16ms 浏览器对每一帧的画面的渲染工作要在16ms内完成，超出时间，页面的渲染就会出现卡顿现象。

* 浏览器在一帧里，会依次执行以下动作

    1. JavaScript:js实现动画效果，Dom元素操作等
    2. Style（计算样式）：确定每个Dom元素应该应用什么CSS规则
    3. Layout（布局）：计算每个DOM元素在最终屏幕上显示的大小和位置。如果有元素的位置发生变化，就会联动的引起其它元素发生变化，这个过程叫回流。
    4. Paint（绘制）：在多个层上绘制DOM元素的文字、颜色、图像、边框和阴影。
    5. Composite(渲染层合并):按照合理的顺序合并图层，然后显示到屏幕上。

* css中的以下属性可以触发GPU加速：

    1. transform
    2. opacity
    3. filter
    4. will-change

    DOM因为上述规则被提升成独立的层（也就是开启GPU加速），一旦被独立出来之后，就不会再影响其它dom的布局。就不会造成dom内其它元素的reflow 和paint。浏览器再次渲染时，只需要进行js》style》composite 步骤。

* GUP加速举例：

    通过改变元素的teansform实现移动、伸缩变换，而非改变物理的left、top、width、height。从而避免layout和paint，让动画效果更加流畅

* 使用GPU加速提升动画性能时，最好给当前动画元素增加一个高一点的z-index属性，人为干扰复合层的排序，可以有效减少浏览器创建不必要的复合层，提升渲染性能

* GUP加速非常耗费内存，需要创建渲染图层，还需要缓存渲染图层，过多的Gpu加速会引起页面卡顿甚至闪退。使用的时候还是需要谨慎。

### 如何减少页面的回流

* 事先设定好图片标签的大小，避免在图片加载完成后，获得图片大小触发回流
* GPU加速
* 避免逐项更改样式，最好一次性更改style属性，或者将样式列表定义为class并且一次性更改class属性
* 避免循环操作DOM。
* 给复杂动画的元素设置绝对定位，使其脱离文档流，避免其它元素的大量回流

### requestAnimationFrame 和 setTimeout区别

requestAnimationFrame 出现之前，前端使用setTimeout或者setInterval实现动画，但是定时器动画存在两个问题：

1. 动画的循环时间间隔不好决定，过长过短都会影响动画的显示效果
2. setTimeout和setInterval都是宏任务，时间参数只是指定了多久后将动画任务添加到浏览器的UI线程队列中，如果UI线程处于忙碌状态，那么动画不会立刻执行。

为了解决这些问题，H5中加入了requestAmimationFrame：

1. requestAnimationFrame 会把每一帧中所有的DOM操作集中起来，在一次重绘或者回流中完成，并且重绘会回流的时间间隔紧紧跟随浏览器的刷新频率
2. 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或者回流，意味着更少的CPU、GPU和内存使用量
3. requestAnimationFrame是有浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，如果页面不是激活状态下的化，动画会自动暂停，有效节省CPU开销

应用场景：

1. js动画
2. 大数据渲染，当要插入页面的数据过大时，可使用requestAnimationFrame进行分步渲染，使得页面加载更加流畅
