---
title: 从浏览器地址栏输入url开始
---
目录：
[[toc]]

### 要点总结

1. DNS解析：将域名解析成IP地址
2. 建立TCP连接：TCP三次握手
3. TLS协商（仅https请求）
4. 发送HTTP请求
5. 服务器处理请求并返回HTTP报文
6. 浏览器解析渲染页面
7. 断开连接：TCP四次挥手

### 详细解析

1. url的定义（Uniform Resource Locator 统一资源定位符），用于定位互联网上的资源，以下面这个为例：

    ```s
      http://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
    ```

    * `http`是协议。它表明了浏览器必须使用哪一种协议，通常为http协议和https协议。[http和https的区别](#http和https的区别)
    web浏览器中常见的是这种，浏览器也知道如何处理其他协议，比如：`mailto:(打开邮件客户端)`或者`ftp:(处理文件传输)`

    * `www.example.com`是域名。它表明正在请求哪个web服务器。或者可以直接使用IP address。DNS（DomainName System 域名系统）的作用就是将域名映射到服务对应的ip地址。

    * `80`是端口。它表示用于访问web服务器伤的资源的技术“门”。如果web服务没有特别指出端口，则使用HTTP协议的默认端口（HTTP：80，HTTPS：443）。

    * `/path/to/myfile.html`是网络服务器上资源的路径。在web的早起阶段，这种路径表示web服务器上物理文件的位置。但是如今，它主要是由没有任何物理实现的web服务器处理的抽象。例如单页面应用的路径并不能表示物理位置，而是运行js代码加载的相对应的资源。

    * `?key1=value1&key2=value2`是提供给网络服务器的额外参数。在返回资源之前，web服务器可以使用这些参数来执行额外的操作。

    * `#SomewhereInTheDocument`是资源身的另一部分的锚点，表示资源中的一种“书签“。比如：在html文档上，浏览器将滚动到定义锚点的位置；在视屏音频文档上，浏览器将尝试转到锚点所代表的时间。且：#后面的内容（片段标志符）不会被发送到请求的服务器,以下图为例，刷新该地址，http请求中并不会将锚点后的内容向服务器进行请求。

    ![url](/images/url.png)
    ![http请求](/images/http.png)

2. 域名与DNS(DomianName System)

    * 域名为互联网可用的网页服务器提供了方便人类理解的地址。当你在注册商那注册了一个域名，几个小时内，所有的DNS服务器都会收到你的DNS信息。我们在访问一个域名的时候，通常会向网络服务商的最底层的DNS服务器查询域名，如果没有查询到，就会去上一级的服务器查询，一直到从顶级服务器中查询到你的域名为止。并且这个结果，会缓存在底层的DNS服务器里。

    * DNS请求的工作流程：

        ```s
        1. 在你的浏览器地址栏输入baidu.com
        2. 浏览器询问计算机是否已经已经识别此域名所确定的IP地址（使用本地DNS缓存）。
           如果是的话，这个域名就会被转换为IP地址，然后浏览器与网络服务器交换内容，结束域名解析流程。
        3. 如果你的计算机不知道baidu.com域名背后的IP,它会询问一个DNS服务器，这个服务器的功能就是告诉你的计算机已经注册的域名所匹配的IP.
        4. 然后计算机就知道了要请求的IP地址，你的浏览器能够与网络服务器建立连接
        ```

3. TCP握手

    握手过程：

    ```s
    1. 客户端发送一个带SYN=1，Seq=X的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
    2. 服务器收到这个数据包之后，发回一个带SYN=1,ACK=X+1,Seq=Y的响应包，传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受请求了，你可以发送了）
    3. 客户端再回传一个带ACK=Y+1,Seq=Z的数据包，代表“握手结束”，连接建立成功，开始数据传输（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）
    ```

    三次握手的原因：

    ```s
    为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
    ```

4. TLS协商。为了在https上建立安全连接，我们需要进行TLS协商。它会决定服务端和客户端进行通信加密使用的秘钥，传播公钥时使用的是非对称加密，然后传输数据时，使用对称加密。

5. 在浏览器和服务器之间，有许多的计算机和其它设备转发了http消息，比如你的路由器、网线。这些主要出现在传输层、网络层和物理层上，所以你的宽带网速，也很大程度上的影响了你网页的加载速度。但是在这中间，我们可能会通过代理，去向服务器请求我们需要的资源。目前适用范围最广的代理是：nginx。

    nginx代理服务器的主要作用：

    * 缓存，但是当cache control: privite时，不允许代理服务器进行缓存
    * 过滤（像反病毒扫描，家长控制）
    * 负载均衡（让多个服务器服务不同的请求）
    * 认证（对不同资源进行权限管理）
    * 日志记录（允许存储历史信息）

6. http请求

    一旦我们建立了到web服务器的连接，浏览器就代表用户发送了一个初始的HTTP GET请求，对于网站来说，这个请求通常是一个HTML文件。一旦服务器收到请求，它将使用相应的响应头和html的内容进行回复。

7. TCP慢开始/14kb规则。 第一个响应包的大小是14kb。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法，慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。在收到初始包之后，服务器会将下一个包的大小加倍到28kb，然后后续包依次是前一个包大小的2倍，直到到达预定的阈值或者遇到堵塞。

8. 一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。这就是为什么在前14kb中包含浏览器开始渲染页面所需的所有内容，至少包含页面模板（第一次渲染所需的css和html）对于web性能优化来说至关重要。

9. 浏览器解析过程：

    * 处理HTML标签并构造DOM树。良好的文档格式，有利于加快dom树的解析速度。dom节点的数量越多，构建dom树需要的时间就越长。
    * 当解析器发现非阻塞资源例如图片或者css文件时，解析也可以继续进行。但是对于`<script>`标签(特别说没有async或者dfer属性的script标签),会阻塞渲染并停止HTML的解析。
    * 可以使用`<link rel="preload" href="main.js" as="script">` link的rel属性配置预加载，这样在随后的页面渲染中，一旦需要使用到它们，它们就立刻可用，不需要停止html解析
    * 接下来是处理css并构建CSSOM树。（尽量避免使用后代选择器，因为css树计算时，先匹配后代，再对父元素进行匹配，相对于具名类选择器来说，性能非常的差）
    * 当css被解析并创建COSSOM时，js文件被解释、编译和执行。脚本被解析为抽象语法树（Abstract Syntax Tree）.一些浏览器引擎使用AST并将其传递到解释器中，输出在主线程执行的字节码。这就是js编译的过程。
    * 浏览器还会构建辅助设备用户分析和解释内容的辅助功能树-可访问性对象模型（AOM）类似DOM的语义版本，这也是为什么我们在开发网页的时候，推荐使用语义化的标签，更加有利于构建清晰的可访问对象。在构建AOM之前，屏幕阅读器无法访问内容
    * dom树和cssom树构造完毕以后，浏览器会将DOM树和cssom树组合成一个Render树，计算render树从dom树的根开始构建，遍历每个可见节点。（display:none的节点不会出现在render树上，visibility:hidden的节点会出现在render树上,且会占用空间）。render树会讲所有相关样式匹配到dom树中的每个可见节点，并根据css的层级确定每个节点的样式。
    * 接下来是在渲染树上运行布局以计算每个节点的几何体。第一次确定节点的大小和位置称为布局。随后对节点的大小和位置的重新计算称为回流。为了确定每个DOM节点的确切大小和位置。浏览器会从渲染树的根开始遍历，因此布局和回流是十分耗费性能的。
    * 最后一步是将各个节点绘制到屏幕上。在绘制阶段，浏览器将把元素的每个可视化部分绘制到屏幕上。绘制可以将布局树中的元素分解为多个层，将内容提升到GPU上的曾，可以提高绘制和重绘的性能。层的确可以提高性能，但是它以内存管理为代价。所以不应该过度使用。
    * 当文档的各个部分以不同的层绘制，互相重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上。
    * 一旦主线绘制页面完成，如果主线程正在解析、编译和执行js，则页面还是无法及时响应用户交互。

### http响应

### http和https的区别

### http1.0 到 http1.1 到http2.0

### preload 的好处

* 更加精确的优化资源加载优先级
* 匹配未来的加载需求，在适当的情况下，重复利用同一资源
* 为资源应用正确的内容安全策略
* 为资源设置正确的Accept请求头

### GPU&web性能优化

### 如何减少页面的回流

* 事先设定好图片标签的大小，避免在图片加载完成后，获得图片大小触发回流

### requestAnimationFrame 和 setTimeout区别

  [requestAnimationFrame](https://juejin.im/entry/6844903600557129736)
